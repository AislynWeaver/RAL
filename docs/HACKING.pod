=head1 HACKING

Hello friends. If you are interested in contributing to the development of
RAL, this file will help you to get started.

First and foremost, ensure that you are on the C<develop> branch. This is
the developer's branch. C<master> is considered production-stable and is
only merged with develop for stable releases.

=head2 SUBMITTING PATCHES / PULL REQUESTS

Either mail me at L<yumi@ral.space|mailto:yumi@ral.space> or join the IRC at
L<howler.space:6667|irc://howler.space:6667> #bigtown. A PR is also fine but
I would prefer that you either send a .patch (for small things), or link me
the repository with your feature branch (for larger things)

=head2 STYLE

In general, I follow a K&R style when writing. If you see any mistakes or
trailing whitespace, you may send a .patch to my e-mail address. or link it
in the IRC. It's a great way to introduce yourself!

=head2 BLOODY DETAILS

This is a break-down of how it all works.

=head3 DATABASE SCHEMA

The text is an important part of a forum / textboard! So the first thing I
will describe is the structure of the data inside our SQL database.

 MariaDB [ral]> SHOW TABLES;
 +---------------+
 | Tables_in_ral |
 +---------------+
 | Bans          |
 | Posts         |
 | Timelines     |
 +---------------+

=head4 C<`Bans`>

 MariaDB [ral]> DESCRIBE `Bans`;
 +-------+--------------+------+-----+---------------------+-------+
 | Field | Type         | Null | Key | Default             | Extra |
 +-------+--------------+------+-----+---------------------+-------+
 | Id    | varchar(256) | NO   | PRI | NULL                |       |
 | Type  | varchar(64)  | NO   |     | NULL                |       |
 | Date  | datetime     | YES  |     | current_timestamp() |       |
 +-------+--------------+------+-----+---------------------+-------+

Banned users get their own special row in C<`Bans`>! Only the C<'SLOW'> ban
type is implemented.

=head4 C<`Posts`>

 MariaDB [ral]> DESCRIBE `Posts`;
 +----------+--------------+------+-----+---------------------+-------+
 | Field    | Type         | Null | Key | Default             | Extra |
 +----------+--------------+------+-----+---------------------+-------+
 | Id       | int(11)      | NO   | PRI | NULL                |       |
 | Created  | datetime     | YES  |     | current_timestamp() |       |
 | Timeline | varchar(16)  | NO   | PRI | NULL                |       |
 | Topic    | int(11)      | NO   |     | NULL                |       |
 | Content  | text         | NO   |     | ''                  |       |
 | Auth     | varchar(512) | NO   |     | NULL                |       |
 +----------+--------------+------+-----+---------------------+-------+

Every row in C<`Posts`> corresponds to a topic or post in any continuity.
You will notice posts are keyed by both their C<`Id`> and C<`Timeline`>,
meaning that the first post on one continuity is independent of the first
post on other continuities. The C<`Auth`> is a hold-over a time where posts
could be "kept open" until purposely closed by the author. Now it simply
confirms which posts you have made.

=head4 C<`Timelines`>

 MariaDB [ral]> DESCRIBE `Timelines`;
 +-------------+-------------+------+-----+---------+-------+
 | Field       | Type        | Null | Key | Default | Extra |
 +-------------+-------------+------+-----+---------+-------+
 | Name        | varchar(16) | NO   | PRI | NULL    |       |
 | Post Count  | int(11)     | YES  |     | 0       |       |
 | Description | varchar(32) | YES  |     | NULL    |       |
 +-------------+-------------+------+-----+---------+-------+

C<`Timelines`> is a bit of a legacy name which has resulted from the many
re-writes of RAL. This table simply contains all of the website's
continuities; the C<`Post Count`> of each continuity increments
independently of the others.

=head3 Posting

When a user opens a postbox, either by clicking "Reply to topic" or "Create
a topic", a I<Robocheck> image is generated using C<CONFIG_WORDLIST>. If you
are able to verify the word engrained in the image, you win! And are allowed
to post,  given that your post length is somewhere between 0 and
C<CONFIG_MAX_POSTLEN>. If C<CONFIG_REALTIME_ENABLE> is toggled, all users
who are "synced" and listening to the conversation are notified in
real-time.

=head3 Real-time Notifications

The real-time component of RAL has proven to be the most difficult thing to
implement, but I think you will find that this has also been given the most
thought.

When you open a part of the website which is updated in real-time, you will
notice a latency meter appear, which reads out your connection time in
miliseconds. If you are ever determined to be "out of sync" with the server,
the latency meter will indicate such. Otherwise, it will continue to update
with your latency every connection you make.

A connection is made to the server from your browser to fetch these
real-time updates using Javascript and the ancient art of I<HTTP
Long-polling>. RAL will soon support I<HTTP Streaming>, which uses less
overhead but requires some more configuration.

When you connect to RAL like this, you are considered "synced"; consequently,
you will receive all updates about the topic you've synced to. This is
accomplished by using SystemV IPC (inter-process communication) schemas like
message queues, shared memory, and semaphores.

=over 8

=item Messge Queues

RAL utilizes a single message queue. Any message sent by any poster anywhere
is sent through this message queue to every listening PHP process. The
process then receives this message and decides if the message is relevant
to the listener's declared interests (topic, continuity, etc). Given that
the message is relevant, the PHP process relays the full message content to
the client.

=item Shared Memory

RAL uses many shared memory allocations of a particular size. The first is a
list of all client IDs. The second is an array of all client details keyed
by their ID. The idea is that listeners do not need to lock the full array
while inserting or removing themselves from the list of clients.


        Shared memory location 1
               (0xC0FFEE)
 +-----------------------------------+
 | c_id 1 | c_id 2 | c_id 3 | c_id 4 |
 +-----------------------------------+
    ||        ||       ||       ||
    ||        ||       ||       ||      +-------+    +-----------+  Shared
    ||        ||       ||       +-----> | C_ID4 | => | last_seen |  memory
    ||        ||       ||               +-------+    +-----------+ (0xC_ID4)
    ||        ||       ||
    ||        ||       ||      +-------+    +-----------+  Shared
    ||        ||       +-----> | C_ID3 | => | last_seen |  memory
    ||        ||               +-------+    +-----------+ (0xC_ID3)
    ||        ||
    ||        ||      +-------+    +-----------+  Shared
    ||        +-----> | C_ID2 | => | last_seen |  memory
    ||                +-------+    +-----------+ (0xC_ID2)
    ||
    ||      +-------+    +-----------+  Shared
    +-----> | C_ID1 | => | last_seen |  memory
            +-------+    +-----------+ (0xC_ID1)

=item Semaphores

RAL uses exactly one semaphore to control the shared memory keyed by
0xC0FFEE. This ensures all operations on the array are atomic (semaphore is
raised on read / write access and lowered at the end of the full operation)
and that all clients who want a message are forwarded one when it arrives

=back

=head4 SystemV (Inter-Process Communication)

Because PHP is only run "on-demand", real-time communication between
posters and listeners invokes the ancient art of inter-process
communication. There are four stages to this fine dance:

1. Client browser connects to server using C<remote_subscribetopic>

2. The PHP process spawned in (1) registers the listener to the shared
memory keyed by 0xC0FFEE

3. The same PHP process then listens to the message queue and blocks
(harmlessly!) until a message is pushed down the queue

4. The PHP process analyzes the message type and determines if it matches
what the client has asked to be notified about. If the message is relevant,
then:

5. The PHP process echoes the JSON encoded message to the user.

This technique is called HTTP long-polling. After the long poll is
initialized, the server then places the $c_id (a randomly generated, unique
ID) into the shared memory location keyed by 0xC0FFEE only after initializing
the shared memory keyed by $c_id with the last_seen timestamp. This lets us
know if a client has "timed out" and should be removed from the list
(presumably the client has recognized the time out and opened another socket
already, in which case they will be in the queue under a different $c_id).

Once in the queue, the user is guaranteed to either receive a message or
time out. When a post is made, a message with a I<type> and I<body> is sent
to every client in the array at 0xC0FFEE.

On the receiving end of the message queue, receiving PHP processes interpret
the message and dispatch it back to the browser if the message is relevant to
the user. The receiving process blocks all input and puts the PHP worker to
sleep until a message is received; B<A CLIENT MAY TIME OUT WHILE THE WORKER
IS ASLEEP>. This makes it necessary to garbage collect these timed out
workers with either with C<request_worker_timeout> in fpm-php or during
listener initialization to ensure we always have enough workers to service
other users.
